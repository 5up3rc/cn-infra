// Copyright (c) 2017 Cisco and/or its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at:
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cassandra

import (
	r "reflect"
	"github.com/ligato/cn-infra/db/sql"
	"github.com/go-errors/errors"
	"bytes"
	"strings"
)

// PutExpToString converts expression to string & slice of bindings
func PutExpToString(whereCondition sql.Expression, entity interface{}) (sqlStr string, bindings []interface{},
	err error) {

	whereCondtionStr := &toStringVisitor{entity: entity}
	whereCondition.Accept(whereCondtionStr)

	statement, _, err := sql.EvaluateUpdate(r.Indirect(r.ValueOf(entity)).Type().Name() /*TODO extract method / make customizable*/ ,
		entity                                                                          /*, TODO TTL*/)
	if err != nil {
		return "", nil, err
	}
	bindings = structFieldPtrs(entity)
	whereBinding := whereCondtionStr.Binding()
	if whereBinding != nil {
		bindings = append(bindings, whereBinding...)
	}

	return strings.Trim(statement+" WHERE"+whereCondtionStr.String(), " "), bindings, nil
}

// SelectExpToString converts expression to string & slice of bindings
func SelectExpToString(fromWhere sql.Expression) (sqlStr string, bindings []interface{},
	err error) {

	findEntity := &findEntityVisitor{}
	fromWhere.Accept(findEntity)

	fromWhereStr := &toStringVisitor{entity: findEntity.entity}
	fromWhere.Accept(fromWhereStr)

	fieldsStr := sql.SelectFields(findEntity.entity)
	if err != nil {
		return "", nil, err
	}
	bindings = structFieldPtrs(findEntity.entity)
	fromWhereBindings := fromWhereStr.Binding()
	if fromWhereBindings != nil {
		bindings = append(bindings, fromWhereBindings)
	}

	return "SELECT " + fieldsStr + " " + fromWhereStr.String(), append(bindings, fromWhereBindings...), nil
}

// ExpToString converts expression to string & slice of bindings
func ExpToString(exp sql.Expression) (sql string, bindings []interface{}, err error) {
	findEntity := &findEntityVisitor{}
	exp.Accept(findEntity)

	stringer := &toStringVisitor{entity: findEntity.entity}
	exp.Accept(stringer)

	return stringer.String(), stringer.Binding(), stringer.lastError
}

type toStringVisitor struct {
	entity    interface{}
	generated bytes.Buffer
	binding   []interface{}
	lastError error
}

// String converts generated byte Buffer to string
func (visitor *toStringVisitor) String() string {
	return visitor.generated.String()
}

// Binding is a getter...
func (visitor *toStringVisitor) Binding() []interface{} {
	return visitor.binding
}

// VisitPrefixedExp generates part of SQL expression
func (visitor *toStringVisitor) VisitPrefixedExp(exp *sql.PrefixedExp) {
	visitor.generated.WriteString(" ")
	visitor.generated.WriteString(exp.Prefix)
	if exp.Prefix == "FROM" {
		visitor.generated.WriteString(" ")
		visitor.generated.WriteString(entityName(visitor.entity))
	}
	if exp.AfterPrefix != nil {
		exp.AfterPrefix.Accept(visitor)
	}
	visitor.generated.WriteString(exp.Suffix)

	if exp.Prefix != "FROM" && exp.Binding != nil && len(exp.Binding) > 0 {
		if visitor.binding != nil {
			visitor.binding = append(visitor.binding, exp.Binding)
		} else {
			visitor.binding = exp.Binding
		}
	}
}
func entityName(entity interface{}) string {
	return r.Indirect(r.ValueOf(entity)).Type().Name()
}

// VisitPrefixedExp generates part of SQL expression
func (visitor *toStringVisitor) VisitFieldExpression(exp *sql.FieldExpression) {
	if visitor.entity == nil {
		visitor.lastError = errors.New("not found entity")
	} else {
		field, found := sql.FindField(exp.PointerToAField, visitor.entity)
		if !found {
			visitor.lastError = errors.New("not found field in entity")
			return
		}
		fieldName, found := sql.FieldName(field)
		if !found {
			visitor.lastError = errors.New("not exported field in entity")
			return
		}
		visitor.generated.WriteString(" ")
		visitor.generated.WriteString(fieldName)

		if exp.AfterField != nil {
			exp.AfterField.Accept(visitor)
		}
	}
}

type findEntityVisitor struct {
	entity interface{}
}

// VisitPrefixedExp checks for "FROM" expression to find out the entity
func (visitor *findEntityVisitor) VisitPrefixedExp(exp *sql.PrefixedExp) {
	if exp.Prefix == "FROM" {
		if len(exp.Binding) == 1 && r.Indirect(r.ValueOf(exp.Binding[0])).Kind() == r.Struct {
			visitor.entity = exp.Binding[0]
		}
	} else if exp.AfterPrefix != nil {
		exp.AfterPrefix.Accept(visitor)
	}
}

// VisitFieldExpression just propagates to AfterFieldExpression
func (visitor *findEntityVisitor) VisitFieldExpression(exp *sql.FieldExpression) {
	if exp.AfterField != nil {
		exp.AfterField.Accept(visitor)
	}
}
